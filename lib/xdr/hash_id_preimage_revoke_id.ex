defmodule StellarBase.XDR.HashIDPreimageRevokeID do
  @moduledoc """
  Automatically generated by xdrgen
  DO NOT EDIT or your changes may be overwritten

  Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr

  Representation of Stellar `HashIDPreimageRevokeID` type.
  """

  @behaviour XDR.Declaration

  alias StellarBase.XDR.{
    AccountID,
    SequenceNumber,
    Uint32,
    PoolID,
    Asset
  }

  @struct_spec XDR.Struct.new(
                 source_account: AccountID,
                 seq_num: SequenceNumber,
                 op_num: Uint32,
                 liquidity_pool_id: PoolID,
                 asset: Asset
               )

  @type source_account_type :: AccountID.t()
  @type seq_num_type :: SequenceNumber.t()
  @type op_num_type :: Uint32.t()
  @type liquidity_pool_id_type :: PoolID.t()
  @type asset_type :: Asset.t()

  @type t :: %__MODULE__{
          source_account: source_account_type(),
          seq_num: seq_num_type(),
          op_num: op_num_type(),
          liquidity_pool_id: liquidity_pool_id_type(),
          asset: asset_type()
        }

  defstruct [:source_account, :seq_num, :op_num, :liquidity_pool_id, :asset]

  @spec new(
          source_account :: source_account_type(),
          seq_num :: seq_num_type(),
          op_num :: op_num_type(),
          liquidity_pool_id :: liquidity_pool_id_type(),
          asset :: asset_type()
        ) :: t()
  def new(
        %AccountID{} = source_account,
        %SequenceNumber{} = seq_num,
        %Uint32{} = op_num,
        %PoolID{} = liquidity_pool_id,
        %Asset{} = asset
      ),
      do: %__MODULE__{
        source_account: source_account,
        seq_num: seq_num,
        op_num: op_num,
        liquidity_pool_id: liquidity_pool_id,
        asset: asset
      }

  @impl true
  def encode_xdr(%__MODULE__{
        source_account: source_account,
        seq_num: seq_num,
        op_num: op_num,
        liquidity_pool_id: liquidity_pool_id,
        asset: asset
      }) do
    [
      source_account: source_account,
      seq_num: seq_num,
      op_num: op_num,
      liquidity_pool_id: liquidity_pool_id,
      asset: asset
    ]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr()
  end

  @impl true
  def encode_xdr!(%__MODULE__{
        source_account: source_account,
        seq_num: seq_num,
        op_num: op_num,
        liquidity_pool_id: liquidity_pool_id,
        asset: asset
      }) do
    [
      source_account: source_account,
      seq_num: seq_num,
      op_num: op_num,
      liquidity_pool_id: liquidity_pool_id,
      asset: asset
    ]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr!()
  end

  @impl true
  def decode_xdr(bytes, struct \\ @struct_spec)

  def decode_xdr(bytes, struct) do
    case XDR.Struct.decode_xdr(bytes, struct) do
      {:ok,
       {%XDR.Struct{
          components: [
            source_account: source_account,
            seq_num: seq_num,
            op_num: op_num,
            liquidity_pool_id: liquidity_pool_id,
            asset: asset
          ]
        }, rest}} ->
        {:ok, {new(source_account, seq_num, op_num, liquidity_pool_id, asset), rest}}

      error ->
        error
    end
  end

  @impl true
  def decode_xdr!(bytes, struct \\ @struct_spec)

  def decode_xdr!(bytes, struct) do
    {%XDR.Struct{
       components: [
         source_account: source_account,
         seq_num: seq_num,
         op_num: op_num,
         liquidity_pool_id: liquidity_pool_id,
         asset: asset
       ]
     }, rest} = XDR.Struct.decode_xdr!(bytes, struct)

    {new(source_account, seq_num, op_num, liquidity_pool_id, asset), rest}
  end
end
