defmodule StellarBase.XDR.SorobanResources do
  @moduledoc """
  Automatically generated by xdrgen
  DO NOT EDIT or your changes may be overwritten

  Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr

  Representation of Stellar `SorobanResources` type.
  """

  @behaviour XDR.Declaration

  alias StellarBase.XDR.{
    LedgerFootprint,
    UInt32
  }

  @struct_spec XDR.Struct.new(
                 footprint: LedgerFootprint,
                 instructions: UInt32,
                 read_bytes: UInt32,
                 write_bytes: UInt32
               )

  @type footprint_type :: LedgerFootprint.t()
  @type instructions_type :: UInt32.t()
  @type read_bytes_type :: UInt32.t()
  @type write_bytes_type :: UInt32.t()

  @type t :: %__MODULE__{
          footprint: footprint_type(),
          instructions: instructions_type(),
          read_bytes: read_bytes_type(),
          write_bytes: write_bytes_type()
        }

  defstruct [:footprint, :instructions, :read_bytes, :write_bytes]

  @spec new(
          footprint :: footprint_type(),
          instructions :: instructions_type(),
          read_bytes :: read_bytes_type(),
          write_bytes :: write_bytes_type()
        ) :: t()
  def new(
        %LedgerFootprint{} = footprint,
        %UInt32{} = instructions,
        %UInt32{} = read_bytes,
        %UInt32{} = write_bytes
      ),
      do: %__MODULE__{
        footprint: footprint,
        instructions: instructions,
        read_bytes: read_bytes,
        write_bytes: write_bytes
      }

  @impl true
  def encode_xdr(%__MODULE__{
        footprint: footprint,
        instructions: instructions,
        read_bytes: read_bytes,
        write_bytes: write_bytes
      }) do
    [
      footprint: footprint,
      instructions: instructions,
      read_bytes: read_bytes,
      write_bytes: write_bytes
    ]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr()
  end

  @impl true
  def encode_xdr!(%__MODULE__{
        footprint: footprint,
        instructions: instructions,
        read_bytes: read_bytes,
        write_bytes: write_bytes
      }) do
    [
      footprint: footprint,
      instructions: instructions,
      read_bytes: read_bytes,
      write_bytes: write_bytes
    ]
    |> XDR.Struct.new()
    |> XDR.Struct.encode_xdr!()
  end

  @impl true
  def decode_xdr(bytes, struct \\ @struct_spec)

  def decode_xdr(bytes, struct) do
    case XDR.Struct.decode_xdr(bytes, struct) do
      {:ok,
       {%XDR.Struct{
          components: [
            footprint: footprint,
            instructions: instructions,
            read_bytes: read_bytes,
            write_bytes: write_bytes
          ]
        }, rest}} ->
        {:ok, {new(footprint, instructions, read_bytes, write_bytes), rest}}

      error ->
        error
    end
  end

  @impl true
  def decode_xdr!(bytes, struct \\ @struct_spec)

  def decode_xdr!(bytes, struct) do
    {%XDR.Struct{
       components: [
         footprint: footprint,
         instructions: instructions,
         read_bytes: read_bytes,
         write_bytes: write_bytes
       ]
     }, rest} = XDR.Struct.decode_xdr!(bytes, struct)

    {new(footprint, instructions, read_bytes, write_bytes), rest}
  end
end
